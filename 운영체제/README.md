# 운영체제
## 운영체제 기본 개념
* 시스템 자원 (또는 자원) : 프로그램 실행에 마땅히 필요한 요소
* 운영체제 : 실행할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램
* 운영체제는 메모리 내 '커널 영역'이라는 공간에 따로 적재되어 실행됨
* 사용자 영역 : 커널 영역을 제외한 나머지 영역, 사용자가 이용하는 응용 프로그램이 적재되는 영역
* 운영체제는 커널 영역에 적재되어 사용자 영역에 적재된 프로그램들에 자원을 할당하고 이들이 올바르게 실행되도록 도움
* 커널 : 운영체제의 핵심부, 운영체제의 핵심 서비스를 담당하는 부분
    * 운영체제 서비스 : 운영체제가 응용 프로그램에 제공하는 기능들
    * 자원에 접근하고 조작하는 기능, 프로그램이 올바르고 안전하게 실행되게 하는 기능 등이 운영체제의 핵심 서비스에 속함
* 사용자 인터페이스 : 사용자가 컴퓨터와 상호작용하는 통로
    * 커널에 포함되지 않는 서비스
    * GUI, CLI로 분류
* 응용 프로그램은 하드웨어 자원에 직접 접근하는 것이 불가능하고, 응용 프로그램의 요청을 받은 운영체제가 대신 자원에 접근하여 요청한 작업을 수행함
    * 이를 이중 모드로 구현
* 이중 모드 : CPU가 명령어를 실행하는 모드를 사용자 모드와 커널 모드로 구분하는 방식
    * 사용자 모드 : 운영체제 서비스를 제공받을 수 없는 실행 모드, 커널 영역의 코드를 실행할 수 없는 모드
        * 일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행됨
        * 사용자 모드로 실행 중인 CPU는 하드웨어 자원에 접근하는 명령어를 실행할 수 없음
    * 커널 모드 : 운영체제 서비스를 제공받을 수 있는 실행 모드, 커널 영역의 코드를 실행할 수 있는 모드
* 시스템 호출 : 운영체제 서비스를 제공받기 위해 커널 모드로 전환하는 방법
    * 시스템 호출은 소프트웨어 인터럽트
    * 소프트웨어 인터럽트 : 특정 명령어에 의해 발생하는 인터럽트
    * 처리 순서
        1. 시스템 호출을 발생시키는 명령어 실행
        2. CPU는 작업을 백업하고, 커널 모드로 전환
        3. 시스템 호출을 수행하는 코드(인터럽트 서비스 루틴, 운영체제 코드)를 실행
        4. 사용자 모드로 복귀하여 기존에 실행하던 프로그램을 이어서 실행
* 운영체제의 핵심 서비스
    * 프로세스 관리
        * 프로세스를 메모리에 적재, 삭제
        * 다양한 프로세스를 관리하고 실행
    * 자원 접근 및 할당
        * 운영체제는 프로세스들이 사용할 자원에 (대신) 접근하고 조작 -> 프로세스는 운영체제를 통해 자원을 이용할 수 있음
        * CPU : 여러 프로세스가 CPU를 이용하므로 CPU 스케줄링 필요
        * 메모리 : 프로세스에 메모리 할당
        * 입출력장치 : 인터럽트 서비스 루틴 제공 (커널 영역에 있음)
    * 파일 시스템 관리

## 프로세스와 스레드
### 프로세스 개요
* 프로세스 : 실행 중인 프로그램
    * 포그라운드 프로세스
    * 백그라운드 프로세스
        * 데몬\[Unix\](서비스\[Window\]) : 사용자와 상호작용하지 않는 백그라운드 프로세스
* 운영체제는 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분 -> 이를 위해 프로세스 제어 블록 이용
* 프로세스 제어 블록 (PCB; Process Control Block)
    * 프로세스와 관련된 정보를 제공하는 자료구조
    * 프로세스 식별 정보, 프로세스 처리에 필요한 정보가 저장됨
    * 프로세스 생성 시 커널 영역에 생성되고 실행이 끝나면 폐기됨
    * PCB에 담기는 정보
        1. 프로세스 ID(PID)
            * 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
        2. 레지스터 값
            * 해당 프로세스가 실행하며 사용했던 레지스터 값
            * 차례가 돌아왔을 때 작업을 이어 실행하기 위해 필요
        3. 프로세스 상태
            * 입출력장치를 사용하기 위해 기다리는 상태, CPU를 이용하고 있는 상태 등
        4. CPU 스케줄링 정보
            * 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
        5. 메모리 관리 정보
            * 프로세스가 메모리 어느 곳에 저장되어 있는지에 대한 정보
            * 베이스 레지스터, 한계 레지스터 값, 페이지 테이블 정보
        6. 사용한 파일과 입출력장치 목록
* 문맥 : 하나의 프로세스 수행을 재개하기 위해 기억해야 할 (중간) 정보
    * 프로세스의 문맥은 해당 프로세스의 PCB에 기록되어 있음
    * 프로세스가 CPU를 사용할 수 있는 시간이 끝나거나 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업
* 문맥 교환 : 기존 프로세스의 문맥을 PCB에 백업하고, 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
    * 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리
    * 문맥 교환이 너무 자주 일어나면 오버헤드가 발생할 수 있음
    * 오버헤드 : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간, 메모리
* 프로세스의 메모리 영역
    * 하나의 프로세스는 사용자 영역에 크게 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장
    * 코드 영역 : CPU가 실행할, 기계어로 이루어진 명령어가 저장되는 공간
        * 읽기 전용 공간
    * 데이터 영역 : 프로그램이 실행되는 내내 유지할 데이터가 저장되는 공간
        * 전역 변수, 정적(static) 필드 등
    * 힙 영역 : 프로그래머가 직접 할당할 수 있는 저장 공간
        * 힙 영역의 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 함 -> 그렇지 않으면 메모리 누수가 발생함
    * 스택 영역 : 데이터를 일시적으로 저장하는 공간
        * 일시적으로 저장되는 데이터에는 매개 변수, 지역 변수 등이 있음
    * 코드 영역과 데이터 영역은 프로세스 실행 과정에서 크기가 고정되므로 정적 할당 영역이라고 부름
    * 힙 영역과 스택 영역은 프로세스 실행 과정에서 크기가 변할 수 있으므로 동적 할당 영역이라고 부름

### 프로세스 상태와 계층 구조
* 프로세스 상태
    1. 생성 상태(new) : 막 메모리에 적재되어 PCB를 할당받은 상태
    2. 준비 상태(ready) : 실행할 준비가 완료되어 CPU 할당을 기다리고 있는 상태
        * 준비 상태인 프로세스가 실행 상태로 전환되는 것을 디스패치라고 함
    3. 실행 상태(running) : CPU를 할당받아 실행 중인 상태
        * 할당된 시간을 모두 사용하면 다시 준비 상태가 됨
        * 입출력장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태가 됨
    4. 대기 상태(blocked) : 입출력장치의 작업을 기다리는 상태
        * 입출력 작업이 완료되면 다시 준비 상태가 됨
    5. 종료 상태(terminated) : 프로세스가 종료된 상태
        * 프로세스가 종료되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함
    * 운영체제는 프로세스 상태를 PCB에 기록하며 프로세스들을 관리함
* 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음
    * 부모 프로세스 : 새 프로세스를 생성한 프로세스
    * 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스
* 프로세스 계층 구조 : 프로세스가 프로세스를 낳는 계층적인 구조 (트리 구조)
* 프로세스 생성 기법
    * 부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성함
        * 자식 프로세스는 부모 프로세스의 복사본이므로 부모 프로세스의 자원들(메모리 내의 내용, 열린 파일의 목록 등)을 상속함
    * fork를 통해 생성된 자식 프로세스는 exec 시스템 호출을 통해 새로운 프로그램 내용으로 전환되어 실행됨
        * 자식 프로세스의 코드 영역과 데이터 영역의 내용이 새로 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화됨
    * 여러 프로세스가 계층적으로 실행되는 과정은 fork와 exec 시스템 호출의 반복임

### 스레드
* 스레드 : 프로세스 내의 실행 흐름 단위
    * 하나의 프로세스는 여러 개의 스레드를 가질 수 있음
    * 단일 스레드 프로세스 : 하나의 실행 흐름을 가지고 한 번에 한 부분만 실행되는 프로세스
    * 멀티 스레드 프로세스 : 프로세스를 구성하는 여러 명령어를 동시에 실행 가능
    * 스레드는 프로세스 내에서 각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터 값, 스택을 가짐
    * 프로세스의 스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 프로세스 자원을 공유하며 실행됨
    * 많은 운영체제는 CPU에 처리할 작업을 전달할 때 스레드 단위로 전달
* 멀티프로세스 : 여러 프로세스를 동시에 실행하는 것
* 멀티스레드 : 여러 스레드로 하나의 프로세스를 동시에 실행하는 것
* 같은 프로세스 내의 모든 스레드는 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하고, 열린 파일과 같은 프로세스 자원을 공유
    * 여러 프로세스를 병행 실행하는 것보다 메모리를 더 효율적으로 사용
    * 스레드 간 협력과 통신에 유리
    * 그러나 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음
* 프로세스 간 통신(IPC; Inter-Process Communication) : 프로세스 간 자원을 공유하고 데이터를 주고받는 것
    * 파일, 공유 메모리 등을 통해 가능

## CPU 스케줄링
### CPU 스케줄링 개요
* CPU 스케줄링 : 운영체제가 프로세스들에게 CPU 자원을 배분하는 방법
* 프로세스 우선순위 : 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 우선순위를 부여
    * 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정함
    * 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행됨
    * 입출력 작업이 많은 프로세스는 우선순위가 높음
        * 대부분의 프로세스는 CPU와 입출력장치를 모두 사용하며 실행되므로 실행 상태와 대기 상태를 반복하며 실행됨
        * 입출력 집중 프로세스 : 입출력 작업이 많은 프로세스, 대기 상태에 더 많이 머무름, 입출력 버스트(입출력장치를 기다리는 작업)가 많은 프로세스
        * CPU 집중 프로세스 : CPU 작업이 많은 프로세스, 실행 상태에 더 많이 머무름, CPU 버스트(CPU를 이용하는 작업)가 많은 프로세스
        * 입출력 집중 프로세스를 먼저 실행시켜 대기 상태로 만들고, CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 효율적임
* 스케줄링 큐
    * 특정 자원을 이용할 프로세스들은 스케줄링 큐에 삽입되어 차례를 기다림 (실제 삽입되는 것은 PCB)
    * 준비 큐 : CPU를 이용할 프로세스들이 삽입되는 큐
        * 운영체제는 PCB들을 준비 큐에 삽입된 순서대로 하나씩 꺼내어 프로세스를 실행하되, 우선순위가 높은 프로세스를 먼저 실행
    * 대기 큐 : 입출력장치를 이용할 프로세스들이 삽입되는 큐
        * 입출력 작업을 요청한 프로세스는 대기 큐에서 작업이 완료되기를 기다림
        * 입출력 완료 인터럽트(하드웨어 인터럽트)가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거, 준비 큐에 삽입함
* 선점형 스케줄링 : 프로세스가 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
    * 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
    * 현재 대부분의 운영체제가 차용하는 방식
* 비선점형 스케줄링 : 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링
    * 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식
* 선점형 스케줄링은 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있으나, 문맥 교환 과정에서 오버헤드가 발생할 수 있음
* 비선점형 스케줄링은 문맥 교환에서 발생하는 오버헤드가 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다려야 하고, 모든 프로세스가 골고루 자원을 사용할 수 없음

### CPU 스케줄링 알고리즘
1. 선입 선처리 스케줄링
    * FCFS 스케줄링
    * 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식
    * 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있음 -> 호위 효과
    * 호위 효과(convoy effect) : 준비 큐에 먼저 삽입된 프로세스의 CPU 버스트 시간이 길면 뒤에 삽입된 프로세스들은 긴 시간을 기다려야 함
2. 최단 작업 우선 스케줄링
    * SJF 스케줄링
    * 준비 큐에 삽입된 프로세스들 중 CPU 이용 시간이 가장 짧은 프로세스부터 실행하는 스케줄링 방식
    * 기본적으로 비선점형 스케줄링 방식으로 분류됨
3. 라운드 로빈 스케줄링
    * 선입 선처리 스케줄링에 타임 슬라이스 개념이 더해진 선점형 스케줄링
    * 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
    * 정해진 시간 내에 프로세스가 완료되지 않으면 다시 준비 큐의 맨 뒤에 삽입
    * 타임 슬라이스 크기가 중요
        * 타임 슬라이스가 지나치게 크면 사실상 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 여지가 있음
        * 타임 슬라이스가 지나치게 작으면 문맥 교환에서 오버헤드 발생
4. 최소 잔여 시간 우선 스케줄링
    * SRT 스케줄링
    * 선점형 최단 작업 우선 스케줄링
    * 프로세스가 준비 큐에 삽입될 때마다 남은 작업 시간이 가장 적은 프로세스를 선택하여 실행 (선점형)
5. 우선순위 스케줄링
    * 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘
    * 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링됨
    * 기아 현상 유발
        * 기아 현상 : 준비 큐에 먼저 삽입되었음에도 불구하고 우선순위가 낮은 프로세스의 실행이 우선순위가 높은 프로세스에 의해 계속 연기되는 현상
        * 이를 해결하기 위해 에이징 기법 도입
        * 에이징 : 대기 중인 프로세스의 우선순위를 점차 증가시키는 방법
6. 다단계 큐 스케줄링
    * 우선순위 스케줄링의 발전된 형태
    * 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
    * 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 그 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리
7. 다단계 피드백 큐 스케줄링
    * 다단계 큐 스케줄링의 발전된 형태
    * 다단계 큐 스케줄링에서는 프로세스들이 큐 사이를 이동할 수 없으므로 기아 현상 발생 -> 이를 보완
    * 프로세스들이 큐 사이를 이동 가능
    * 새로 준비 상태가 된 프로세스는 가장 높은 우선순위 큐에 삽입되고 일정 시간(타임 슬라이스) 동안 실행됨
    * 해당 큐에서 실행이 끝나지 않으면 다음 우선순위 큐에 삽입되어 실행됨
        * CPU 집중 프로세스들은 CPU를 비교적 오래 사용하므로 자연스레 우선순위가 낮아짐
        * 입출력 집중 프로세스들은 CPU를 비교적 적게 사용하므로 우선순위가 높은 큐에서 실행 완료됨
    * 낮은 우선순위 큐에서 기다리고 있는 프로세스는 점차 우선순위가 높은 큐로 이동 (에이징 기법) -> 기아 현상 예방
    * 구현이 복잡하지만 가장 일반적인 CPU 스케줄링 알고리즘

## 동기화
### 동기화 개요
* 프로세스 동기화 : 동시에 실행되는 프로세스들 사이에 수행 시기를 맞추는 것
    * 실행 순서 제어를 위한 동기화 : 프로세스를 올바른 순서대로 실행하기
    * 상호 배제를 위한 동기화 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기
    * 스레드도 동기화 대상 (실행의 흐름을 갖는 모든 것은 동기화 대상)
* 공유 자원 : 공동으로 사용하는 자원
    * 전역 변수, 파일, 입출력장치, 보조기억장치 등
* 임계 구역 : 공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생하는 코드 영역
    * 임계 구역에 진입한 프로세스가 있다면 다른 프로세스는 임계 구역 밖에서 기다려야 함
* 레이스 컨디션 : 잘못된 실행으로 인해 여러 프로세스가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 경우
    * 레이스 컨디션이 발생하면 자원(데이터)의 일관성이 깨짐
* 상호 배제를 위한 동기화 : 레이스 컨디션이 발생하지 않도록 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것
    * 이를 위해 세 가지 원칙이 지켜져야 함
        1. 상호 배제 : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없음
        2. 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 함
        3. 유한 대기 : 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 함(임계 구역에 들어오기 위해 무한정 대기해서는 안 됨)

### 동기화 기법
* 뮤텍스 락(Mutex lock; MUTual EXclusion lock)
    * 상호 배제를 위한 동기화 도구
    * 매우 단순한 형태의 뮤텍스 락은 다음과 같이 구성
        * 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
        * 임계 구역을 잠그는 역할 : acquire 함수
        * 임계 구역의 잠금을 해제하는 역할 : release 함수
        * 임계 구역 진입 전후로 acquire 함수와 release 함수 호출
    * 프로세스는 락을 획득할 수 없다면 무작정 기다리고, 락을 획득할 수 있다면 임계 구역을 잠근 뒤 임계 구역에서의 작업을 진행하고, 임계 구역에서 빠져나올 때엔 다시 임계 구역의 잠금을 해제함으로써 임계 구역을 보호함
    * 임계 구역이 잠겨 있을 경우 프로세스는 반복적으로 lock을 확인함 -> 바쁜 대기
* 세마포(semaphore)
    * 공유 자원이 여러 개 있는 상황에서 적용 가능한 동기화 도구
    * 뮤텍스 락과 비슷하게 하나의 변수와 두 개의 함수로 단순하게 구현 가능
        * 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역 변수 S
        * 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
        * 임계 구역 앞에서 기다리는 프로세스에 진입 신호를 주는 signal 함수
        * 임계 구역 진입 전후로 wait 함수와 signal 함수 호출
    * 바쁜 대기 문제가 발생 -> CPU 주기를 낭비 -> 세마포를 위한 대기 큐를 이용하여 문제 해결
        * wait 함수는 사용할 수 있는 자원이 없을 경우 해당 프로세스 상태를 대기 상태로 만들고, PCB를 세마포를 위한 대기 큐에 삽입
        * 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면 signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨 줌 -> 임계 구역 진입
    * 실행 순서 제어를 위한 동기화에도 사용 가능
        * 세마포의 변수 S를 0으로 설정하고 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수를 붙임
* 모니터(monitor)
    * 공유 자원과 공유 자원에 접근하기 위한 인터페이스를 묶어 관리
    * 모니터에 진입하기 위한 큐를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 하여 상호 배제를 위한 동기화를 제공
    * 조건 변수를 사용하여 실행 순서 제어를 위한 동기화를 제공
        * 조건 변수로 wait, signal 연산을 수행할 수 있음 ex) x.wait(), y.signal()
            * wait는 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 조건 변수에 대한 대기 큐에 삽입하는 연산
            * signal은 wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산
        * 특정 프로세스가 아직 실행할 조건이 되지 않았을 때는 wait를 통해 실행을 중단
        * 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개
