# 데이터베이스
## 데이터베이스 개념
### 관계 데이터 모델
* 키 : 릴레이션(테이블)에서 특정 투플(행)을 식별할 때 사용하는 속성(열) 또는 속성의 집합
    * 키는 릴레이션 간 연결고리 역할도 함

    * 종류
        1. 슈퍼키 : 투플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합
        2. 후보키 : 투플을 유일하게 식별할 수 있는 속성의 최소 집합
        3. 기본키 : 여러 후보키 중 하나를 선정하여 대표로 삼는 키
        4. 대리키(인조키) : 일련번호 같은 가상의 속성을 만들어 기본키로 삼는 키
            * DBMS나 관련 소프트웨어에서 임의로 생성하는 값으로 사용자가 직관적으로 그 값의 의미를 알 수 없음
        5. 대체키 : 기본키로 선정되지 않은 후보키
        6. 외래키 : 다른 릴레이션의 기본키를 참조하는 속성

* 무결성 제약조건
    * 데이터 무결성 : 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것

    * 종류
        1. 도메인 무결성 제약조건(도메인 제약)
            * 릴레이션 내의 투플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건
        2. 개체 무결성 제약조건(기본키 제약)
            * 릴레이션은 기본키를 지정해야 하고, 기본키는 NULL 값이 아닌 유일한 값이어야 한다는 조건
        3. 참조 무결성 제약조건(외래키 제약)
            * 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 속성의 도메인이 동일해야 하고, 자식 릴레이션이 참조하고 있는 값을 부모 릴레이션에서 삭제/변경하는 경우 제약을 받는다는 조건
            * 부모 릴레이션에서 투플을 삭제하는 경우 옵션 (참조 무결성 제약조건을 수행하기 위한 옵션)
                * RESTRICTED : 부모 릴레이션 투플 삭제 거부
                * CASCADE : 관련 자식 릴레이션 투플 같이 삭제
                * DEFAULT : 자식 릴레이션 외래키를 미리 설정해 둔 값으로 변경
                * NULL : 자식 릴레이션 외래키를 NULL 값으로 변경

## 데이터베이스 프로그래밍
### SQL 개요
* 데이터 정의어(DDL) : 테이블이나 관계의 구조를 생성하는 데 사용하며 CREATE, ALTER, DROP 문 등이 있음
* 데이터 조작어(DML) : 테이블에 데이터를 검색, 삽입, 수정, 삭제하는 데 사용하며 SELECT, INSERT, UPDATE, DELETE 문 등이 있음
* 데이터 제어어(DCL) : 데이터의 사용 권한을 관리하는 데 사용하며 GRANT, REVOKE 문 등이 있음

### 데이터 조작어 - 검색
* SELECT 문 : 데이터를 조회하는 명령어, 질의어(query)라고 부름
    * 문법
        * SELECT [ALL | DISTINCT] 속성이름
        * FROM 테이블이름
        * WHERE 검색조건
        * GROUP BY 속성이름
        * HAVING 검색조건
        * ORDER BY 속성이름 [ASC | DESC]

* SQL 문은 관계대수와 달리 기본적으로 중복을 제거하지 않음
    * 중복을 제거하고 싶으면 DISTINCT 키워드를 사용

* 두 개 이상 테이블에서의 SQL 질의
    * 조인(join)
    * 부속질의(subquery) : SELECT 문의 WHERE 절에 또 다른 테이블 결과를 이용하기 위해 다시 SELECT 문을 괄호로 묶는 것
        * 부속질의 간에는 상하관계가 있으며 하위 부속질의를 먼저 실행하고 그 결과를 이용하여 상위 부속질의를 실행
        * 상관 부속질의(correlated subquery)는 상위 부속질의의 투플을 이용하여 하위 부속질의를 계산하고 이를 다시 이용하여 상위 부속질의를 실행
            * 상위 부속질의와 하위 부속질의가 독립적이지 않고 서로 관련을 맺고 있음
    * 집합 연산
        * 합집합 : UNION, UNION ALL(중복을 포함하여 모든 결과를 구하는 경우)
        * 차집합 : MINUS, NOT IN (MySQL의 경우)
        * 교집합 : INTERSECT, IN (MySQL의 경우)
    * EXISTS, NOT EXISTS
        * 상관 부속질의문 형식으로, WHERE [NOT] EXISTS (SELECT ~ )와 같이 사용
        * EXISTS는 하위 부속질의에서 조건에 맞는 투플이 하나라도 존재하면 해당 상위 부속질의의 투플을 결과에 포함시킴
        * NOT EXISTS는 하위 부속질의에서 조건에 맞는 투플이 존재하지 않는 경우에만 해당 상위 부속질의의 투플을 결과에 포함시킴

### 데이터 정의어
* CREATE 문 : 테이블을 구성하고, 속성과 속성에 관한 제약을 정의하며, 기본키 및 외래키를 정의하는 명령
    * 문법
        * CREATE TABLE 테이블이름
        * ( 속성이름 데이터타입 [NULL | NOT NULL | UNIQUE | DEFAULT 기본값 | CHECK 체크조건]
        * PRIMARY KEY 속성이름
        * FOREIGN KEY 속성이름 REFERENCES 테이블이름(속성이름)
        * ON DELETE CASCADE | SET NULL
        * )
            * ON DELETE 옵션을 명시하지 않으면 RESTRICT임(외래키에 의해 참조되는 투플은 삭제 불가)

* 문자형 데이터 타입 CHAR, VARCHAR
    * CHAR(n) : 저장되는 문자의 길이가 n보다 작으면 나머지는 공백으로 채움
    * VARCHAR(n) : 저장되는 문자의 길이만큼만 기억장소를 차지함
    * CHAR는 데이터를 읽을 때 성능 이점이 있고, VARCHAR는 저장 효율이 좋음

* ALTER 문 : 생성된 테이블의 속성과 속성에 관한 제약을 변경하며, 기본키 및 외래키를 변경하는 명령
    * 문법
        * ALTER TABLE 테이블이름
        * ADD COLUMN 속성이름 데이터타입
        * DROP COLUMN 속성이름
        * MODIFY COLUMN 속성이름 데이터타입 제약조건
        * CHANGE COLUMN 속성이름 바꿀속성이름 데이터타입 제약조건
        * ADD PRIMARY KEY(속성이름)
        * ADD FOREIGN KEY(속성이름) REFERENCES 참조테이블이름(참조속성이름)
        * ADD | DROP CONSTRAINT 제약이름

* DROP 문 : 테이블을 삭제하는 명령
    * 테이블의 구조와 데이터를 모두 삭제
    * 데이터만 삭제하려면 DELETE 문을 사용
    * 문법
        * DROP TABLE 테이블이름

### 데이터 조작어 - 삽입, 수정, 삭제
* INSERT 문 : 테이블에 새로운 투플을 삽입하는 명령
    * 문법
        * INSERT INTO 테이블 이름(속성리스트)
        * VALUES (값리스트)

* 대량 삽입(bulk insert) : 여러 개의 투플을 한 번에 삽입하는 방법
    * INSERT INTO 테이블 이름(속성리스트) SELECT ~

* UPDATE 문 : 특정 속성 값을 수정하는 명령
    * 문법
        * UPDATE 테이블이름
        * SET 속성이름 1=값 1, 속성이름 2=값 2, ...
        * WHERE 검색조건

* DELETE 문 : 테이블에 있는 기존 투플을 삭제하는 명령
    * 문법
        * DELETE FROM 테이블이름
        * WHERE 검색조건

### 내장 함수
* 사용 예시 1
    * SELECT 함수명(인자1, 인자2, ...)
    * FROM 테이블이름
    * WHERE 열이름=함수명(인자1, 인자2, ...)
* 사용 예시 2
    * UPDATE 테이블이름
    * SET 열이름=함수명(인자1, 인자2, ...)

### 부속질의
* 부속질의(subquery) : 하나의 SQL 문 안에 다른 SQL 문이 중첩된 질의
    * 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용
    * 위치와 역할에 따라 스칼라 부속질의, 인라인 뷰, 중첩질의로 분류

* 스칼라 부속질의 - SELECT 부속질의
    * SELECT 절에서 사용되는 부속질의
    * 부속질의의 결과 값을 단일 행, 단일 열의 스칼라 값으로 반환
    * 원칙적으로 스칼라 값이 들어갈 수 있는 모든 곳에 사용 가능하며, 일반적으로 SELECT 문과 UPDATE SET 절에 사용
    * 주질의와 부속질의의 관계는 상관/비상관 모두 가능

* 인라인 뷰 - FROM 부속질의
    * FROM 절에서 사용되는 부속질의
    * 뷰(view) : 기본 테이블로부터 일시적으로 만들어진 가상의 테이블

* 중첩질의 - WHERE 부속질의
    * WHERE 절에서 사용되는 부속질의
    * 술어(predicate)와 같이 사용 ,
    

### 뷰
* 뷰 : 하나 이상의 테이블을 합하여 만든 가상의 테이블
    * SELECT 문의 결과를 가상의 테이블로 정의하여 실제 테이블처럼 사용할 수 있도록 만든 데이터베이스 개체
    * DBMS는 뷰를 생성할 때 사용한 SELECT 문의 정의를 저장함

* 뷰의 생성
    * 문법
        * CREATE VIEW 뷰이름 (열이름1, 열이름2, ...)
        * AS SELECT 문

* 뷰의 수정
    * 뷰에 정의된 SQL 문을 수정
    * 문법
        * CREATE OR REPLACE VIEW 뷰이름 (열이름1, 열이름2, ...)
        * AS SELECT 문
    
* 뷰의 삭제
    * 문법
        * DROP VIEW 뷰이름

### 인덱스
* 인덱스 : 데이터베이스 테이블을 빠르게 조회할 수 있도록 만든 자료구조

* 인덱스의 장점
    * 테이블 조회 속도와 그에 따른 성능을 향상시킬 수 있음
    * 전반적인 시스템의 부하를 줄일 수 있음

* 인덱스의 단점
    * 인덱스를 관리하기 위해 데이터베이스의 약 10%에 해당하는 저장공간이 필요
    * 인덱스 관리를 위한 추가 작업이 필요
    * 인덱스를 잘못 사용할 경우 오히려 성능이 저하될 수 있음
        * 삽입, 수정, 삭제가 빈번한 속성에 인덱스를 생성하면 추가 작업에 더해 인덱스의 크기가 비대해져서 성능이 오히려 저하됨
        * 수정 및 삭제 시 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 하기 때문

* 인덱스를 사용하면 좋은 경우
    * 규모가 작지 않은 테이블
    * 삽입, 수정, 삭제가 자주 발생하지 않는 컬럼
    * 조인이나 WHERE 절에 자주 사용되는 컬럼
    * 데이터의 중복도가 낮은 컬럼

* 일반적인 RDBMS의 인덱스는 B-Tree 구조로 되어 있음
    * B-Tree(Balanced Tree) : 데이터의 검색 시간을 단축하기 위한 자료구조로, 리프 노드가 모두 같은 레벨에 존재하는 균형 트리 -> 탐색 트리의 일종
        * 인덱스에 사용되는 B-Tree의 경우 리프 노드만 인덱스(key)와 함께 데이터(value)를 가지고 있음
            * 일반적으로 데이터는 인덱스에 해당하는 테이블 행 위치를 나타냄

* 인덱스 생성
    * 문법
        * CREATE [UNIQUE] INDEX 인덱스이름
        * ON 테이블이름(컬럼1 [ASC | DESC], 컬럼2 [ASC | DESC], ...)
            * UNIQUE INDEX를 사용하는 경우 해당 컬럼(들)에 UNIQUE 제약조건이 걸림

    * 생성된 인덱스는 'SHOW INDEX FROM 테이블이름'으로 확인

* B-Tree 인덱스의 경우 데이터의 수정, 삭제가 잦으면 삭제된 레코드의 인덱스 값 자리가 비게 되는(사용하지 않음 처리) 단편화(fragmentation) 현상이 나타나 검색시 성능 저하로 이어짐(실제 데이터 양에 비해 인덱스가 비대해지므로)
    * 인덱스 재구성이 필요 (인덱스를 다시 생성)

* 인덱스 재구성
    * 문법
        * ANALYZE TABLE 테이블이름

* 인덱스 삭제
    * 문법
        * DROP INDEX 인덱스이름 ON 테이블이름
    * 하나의 테이블에 인덱스가 많으면 데이터베이스 성능에 좋지 않은 영향을 미치므로 사용하지 않는 인덱스는 삭제해야 함

## 데이터베이스 설계
### 이상현상
* 이상현상 : 잘못 설계된 테이블로 삽입, 삭제, 수정 같은 작업을 했을 때 생기는 현상으로 데이터베이스의 일관성을 훼손하여 데이터의 무결성을 깨뜨림
    * 이상현상의 종류
        * 삭제이상 : 투플 삭제 시 하나의 정보를 삭제함으로써 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
        * 삽입이상 : 투플 삽입 시 제공되지 못하는 속성 값을 NULL 값으로 입력해야 하는 현상
        * 수정이상 : 투플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상 (데이터의 일관성이 깨짐)

### 함수 종속성
* 함수 종속성 : 릴레이션 R과 R에 속하는 속성 집합 X, Y가 있을 때 X 각각의 값이 Y의 값 한 개와 대응될 때(Y의 값을 유일하게 결정할 때) 'X는 Y를 함수적으로 결정한다'라고 하고 X -> Y로 표기함
    * 이때 X를 결정자, Y를 종속 속성이라고 함
* 이상현상은 비후보키 결정자 속성이 있을 때 발생하므로 릴레이션을 분해하여 비후보키 결정자 속성을 없애야 함
    * 비후보키 결정자 속성이 있다는 것은 한 릴레이션에 두 가지 이상의 정보가 저장되어 있다는 의미임
    * 분해된 부분 릴레이션의 결정자는 원래 릴레이션에 남겨두어야 부분 릴레이션이 원래 릴레이션과 조인을 통해 다시 관계를 형성할 수 있음

### 정규화
* 정규화 : 릴레이션을 분해하여 이상현상을 제거하는 과정
* 정규형
    * 릴레이션은 정규형이라는 개념으로 분류 가능하고, 정규형이 높을수록 이상현상이 줄어듦
    * 종류
        * 제 1정규형 : 릴레이션 R의 모든 속성값이 원자값을 가지면 제 1정규형이라고 함
        * 제 2정규형 : 릴레이션 R이 제 1정규형이고 모든 비후보키 속성이 후보키에 완전 함수 종속일 때 제 2정규형이라고 함
            * 완전 함수 종속 : A, B가 릴레이션 R의 속성이고 A -> B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 임의의 진부분집합 속성에 함수 종속하지 않을 경우 완전 함수 종속이라고 함
        * 제 3정규형 : 릴레이션 R이 제 2정규형이고 모든 비후보키 속성이 후보키에 비이행적으로 종속(직접 종속)할 때 제 3정규형이라고 함
            * 이행적 종속이란 A -> B, B -> C가 성립할 때 A -> C가 성립되는 함수 종속성을 말함
        * BCNF(Boyce Codd Normal Form) : 릴레이션 R에서 함수 종속성 X -> Y가 성립할 때 모든 결정자 X가 후보키이면(비후보키 결정자 속성이 없으면) BCNF임
        * 제 4정규형, 제 5정규형도 있으나 대부분의 릴레이션은 BCNF까지 정규화하면 실제적인 이상현상은 없어지므로 보통 BCNF까지 정규화를 진행함

* 정규화를 위해 릴레이션을 분해할 때는 분해된 릴레이션 간의 관계를 유지하기 위해 분해된 릴레이션에 공통 속성을 두어야 함
    * 공통 속성은 분해된 릴레이션을 다시 원래의 릴레이션으로 합성(조인)할 때 사용함
    * 어떤 속성을 공통 속성으로 해야 하는지는 무손실 분해 규칙을 통해 알 수 있음

* 무손실 분해 : 릴레이션 R을 릴레이션 R1과 R2로 분해했을 때, R1과 R2를 조인해서 R을 생성할 수 있으면 무손실 분해라고 함
    * 무손실 분해의 조건은 R1과 R2의 공통 속성이 R1 또는 R2의 키인 것임 (무손실 분해 규칙)

## 데이터베이스 관리
### 트랜잭션
* 트랜잭션 : DBMS에서 데이터를 다루는 논리적인 작업 단위
* 트랜잭션의 4가지 성질 (ACID 성질)
    * 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 함(all or nothing)
    * 일관성(Consistency) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관성 있는 상태를 유지해야 함
    * 고립성(Isolation) : 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장해야 함
    * 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함

