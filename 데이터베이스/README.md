# 데이터베이스
## 데이터베이스 개념
### 관계 데이터 모델
* 키 : 릴레이션(테이블)에서 특정 투플(행)을 식별할 때 사용하는 속성(열) 또는 속성의 집합
    * 키는 릴레이션 간 연결고리 역할도 함

    * 종류
        1. 슈퍼키 : 투플을 유일하게 식별할 수 있는 하나의 속성 혹은 속성의 집합
        2. 후보키 : 투플을 유일하게 식별할 수 있는 속성의 최소 집합
        3. 기본키 : 여러 후보키 중 하나를 선정하여 대표로 삼는 키
        4. 대리키(인조키) : 일련번호 같은 가상의 속성을 만들어 기본키로 삼는 키
            * DBMS나 관련 소프트웨어에서 임의로 생성하는 값으로 사용자가 직관적으로 그 값의 의미를 알 수 없음
        5. 대체키 : 기본키로 선정되지 않은 후보키
        6. 외래키 : 다른 릴레이션의 기본키를 참조하는 속성

* 무결성 제약조건
    * 데이터 무결성 : 데이터베이스에 저장된 데이터의 일관성과 정확성을 지키는 것

    * 종류
        1. 도메인 무결성 제약조건(도메인 제약)
            * 릴레이션 내의 투플들이 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건
        2. 개체 무결성 제약조건(기본키 제약)
            * 릴레이션은 기본키를 지정해야 하고, 기본키는 NULL 값이 아닌 유일한 값이어야 한다는 조건
        3. 참조 무결성 제약조건(외래키 제약)
            * 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 속성의 도메인이 동일해야 하고, 자식 릴레이션이 참조하고 있는 값을 부모 릴레이션에서 삭제/변경하는 경우 제약을 받는다는 조건
            * 부모 릴레이션에서 투플을 삭제하는 경우 옵션 (참조 무결성 제약조건을 수행하기 위한 옵션)
                * RESTRICTED : 부모 릴레이션 투플 삭제 거부
                * CASCADE : 관련 자식 릴레이션 투플 같이 삭제
                * DEFAULT : 자식 릴레이션 외래키를 미리 설정해 둔 값으로 변경
                * NULL : 자식 릴레이션 외래키를 NULL 값으로 변경

## 데이터베이스 프로그래밍
### SQL 개요
* 데이터 정의어(DDL) : 테이블이나 관계의 구조를 생성하는 데 사용하며 CREATE, ALTER, DROP 문 등이 있음
* 데이터 조작어(DML) : 테이블에 데이터를 검색, 삽입, 수정, 삭제하는 데 사용하며 SELECT, INSERT, UPDATE, DELETE 문 등이 있음
* 데이터 제어어(DCL) : 데이터의 사용 권한을 관리하는 데 사용하며 GRANT, REVOKE 문 등이 있음

### 데이터 조작어 - 검색
* SELECT 문 : 데이터를 조회하는 명령어, 질의어(query)라고 부름
    * 문법
        * SELECT [ALL | DISTINCT] 속성이름
        * FROM 테이블이름
        * WHERE 검색조건
        * GROUP BY 속성이름
        * HAVING 검색조건
        * ORDER BY 속성이름 [ASC | DESC]

* SQL 문은 관계대수와 달리 기본적으로 중복을 제거하지 않음
    * 중복을 제거하고 싶으면 DISTINCT 키워드를 사용

* 두 개 이상 테이블에서의 SQL 질의
    * 조인(join)
    * 부속질의(subquery) : SELECT 문의 WHERE 절에 또 다른 테이블 결과를 이용하기 위해 다시 SELECT 문을 괄호로 묶는 것
        * 부속질의 간에는 상하관계가 있으며 하위 부속질의를 먼저 실행하고 그 결과를 이용하여 상위 부속질의를 실행
        * 상관 부속질의(correlated subquery)는 상위 부속질의의 투플을 이용하여 하위 부속질의를 계산하고 이를 다시 이용하여 상위 부속질의를 실행
            * 상위 부속질의와 하위 부속질의가 독립적이지 않고 서로 관련을 맺고 있음
    * 집합 연산
        * 합집합 : UNION, UNION ALL(중복을 포함하여 모든 결과를 구하는 경우)
        * 차집합 : MINUS, NOT IN (MySQL의 경우)
        * 교집합 : INTERSECT, IN (MySQL의 경우)
    * EXISTS, NOT EXISTS
        * 상관 부속질의문 형식으로, WHERE [NOT] EXISTS (SELECT ~ )와 같이 사용
        * EXISTS는 하위 부속질의에서 조건에 맞는 투플이 하나라도 존재하면 해당 상위 부속질의의 투플을 결과에 포함시킴
        * NOT EXISTS는 하위 부속질의에서 조건에 맞는 투플이 존재하지 않는 경우에만 해당 상위 부속질의의 투플을 결과에 포함시킴

### 데이터 정의어
* CREATE 문 : 테이블을 구성하고, 속성과 속성에 관한 제약을 정의하며, 기본키 및 외래키를 정의하는 명령
    * 문법
        * CREATE TABLE 테이블이름
        * ( 속성이름 데이터타입 [NULL | NOT NULL | UNIQUE | DEFAULT 기본값 | CHECK 체크조건]
        * PRIMARY KEY 속성이름
        * FOREIGN KEY 속성이름 REFERENCES 테이블이름(속성이름)
        * ON DELETE CASCADE | SET NULL
        * )
            * ON DELETE 옵션을 명시하지 않으면 RESTRICT임(외래키에 의해 참조되는 투플은 삭제 불가)

* 문자형 데이터 타입 CHAR, VARCHAR
    * CHAR(n) : 저장되는 문자의 길이가 n보다 작으면 나머지는 공백으로 채움
    * VARCHAR(n) : 저장되는 문자의 길이만큼만 기억장소를 차지함
    * CHAR는 데이터를 읽을 때 성능 이점이 있고, VARCHAR는 저장 효율이 좋음

* ALTER 문 : 생성된 테이블의 속성과 속성에 관한 제약을 변경하며, 기본키 및 외래키를 변경하는 명령
    * 문법
        * ALTER TABLE 테이블이름
        * ADD COLUMN 속성이름 데이터타입
        * DROP COLUMN 속성이름
        * MODIFY COLUMN 속성이름 데이터타입 제약조건
        * CHANGE COLUMN 속성이름 바꿀속성이름 데이터타입 제약조건
        * ADD PRIMARY KEY(속성이름)
        * ADD FOREIGN KEY(속성이름) REFERENCES 참조테이블이름(참조속성이름)
        * ADD | DROP CONSTRAINT 제약이름

* DROP 문 : 테이블을 삭제하는 명령
    * 테이블의 구조와 데이터를 모두 삭제
    * 데이터만 삭제하려면 DELETE 문을 사용
    * 문법
        * DROP TABLE 테이블이름

### 데이터 조작어 - 삽입, 수정, 삭제
* INSERT 문 : 테이블에 새로운 투플을 삽입하는 명령
    * 문법
        * INSERT INTO 테이블 이름(속성리스트)
        * VALUES (값리스트)

* 대량 삽입(bulk insert) : 여러 개의 투플을 한 번에 삽입하는 방법
    * INSERT INTO 테이블 이름(속성리스트) SELECT ~

* UPDATE 문 : 특정 속성 값을 수정하는 명령
    * 문법
        * UPDATE 테이블이름
        * SET 속성이름 1=값 1, 속성이름 2=값 2, ...
        * WHERE 검색조건

* DELETE 문 : 테이블에 있는 기존 투플을 삭제하는 명령
    * 문법
        * DELETE FROM 테이블이름
        * WHERE 검색조건

### 내장 함수
* 사용 예시 1
    * SELECT 함수명(인자1, 인자2, ...)
    * FROM 테이블이름
    * WHERE 열이름=함수명(인자1, 인자2, ...)
* 사용 예시 2
    * UPDATE 테이블이름
    * SET 열이름=함수명(인자1, 인자2, ...)

### 부속질의
* 부속질의(subquery) : 하나의 SQL 문 안에 다른 SQL 문이 중첩된 질의
    * 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용
    * 위치와 역할에 따라 스칼라 부속질의, 인라인 뷰, 중첩질의로 분류

* 스칼라 부속질의 - SELECT 부속질의
    * SELECT 절에서 사용되는 부속질의
    * 부속질의의 결과 값을 단일 행, 단일 열의 스칼라 값으로 반환
    * 원칙적으로 스칼라 값이 들어갈 수 있는 모든 곳에 사용 가능하며, 일반적으로 SELECT 문과 UPDATE SET 절에 사용
    * 주질의와 부속질의의 관계는 상관/비상관 모두 가능

* 인라인 뷰 - FROM 부속질의
    * FROM 절에서 사용되는 부속질의
    * 뷰(view) : 기본 테이블로부터 일시적으로 만들어진 가상의 테이블

* 중첩질의 - WHERE 부속질의
    * WHERE 절에서 사용되는 부속질의
    * 술어(predicate)와 같이 사용 ,
    

### 뷰
* 뷰 : 하나 이상의 테이블을 합하여 만든 가상의 테이블
    * SELECT 문의 결과를 가상의 테이블로 정의하여 실제 테이블처럼 사용할 수 있도록 만든 데이터베이스 개체
    * DBMS는 뷰를 생성할 때 사용한 SELECT 문의 정의를 저장함

* 뷰의 생성
    * 문법
        * CREATE VIEW 뷰이름 (열이름1, 열이름2, ...)
        * AS SELECT 문

* 뷰의 수정
    * 뷰에 정의된 SQL 문을 수정
    * 문법
        * CREATE OR REPLACE VIEW 뷰이름 (열이름1, 열이름2, ...)
        * AS SELECT 문
    
* 뷰의 삭제
    * 문법
        * DROP VIEW 뷰이름

### 인덱스
* 인덱스 : 데이터베이스 테이블을 빠르게 조회할 수 있도록 만든 자료구조

* 인덱스의 장점
    * 테이블 조회 속도와 그에 따른 성능을 향상시킬 수 있음
    * 전반적인 시스템의 부하를 줄일 수 있음

* 인덱스의 단점
    * 인덱스를 관리하기 위해 데이터베이스의 약 10%에 해당하는 저장공간이 필요
    * 인덱스 관리를 위한 추가 작업이 필요
    * 인덱스를 잘못 사용할 경우 오히려 성능이 저하될 수 있음
        * 삽입, 수정, 삭제가 빈번한 속성에 인덱스를 생성하면 추가 작업에 더해 인덱스의 크기가 비대해져서 성능이 오히려 저하됨
        * 수정 및 삭제 시 기존의 인덱스를 삭제하지 않고 '사용하지 않음' 처리를 하기 때문

* 인덱스를 사용하면 좋은 경우
    * 규모가 작지 않은 테이블
    * 삽입, 수정, 삭제가 자주 발생하지 않는 컬럼
    * 조인이나 WHERE 절에 자주 사용되는 컬럼
    * 데이터의 중복도가 낮은 컬럼

* 일반적인 RDBMS의 인덱스는 B-Tree 구조로 되어 있음
    * B-Tree(Balanced Tree) : 데이터의 검색 시간을 단축하기 위한 자료구조로, 리프 노드가 모두 같은 레벨에 존재하는 균형 트리 -> 탐색 트리의 일종
        * 인덱스에 사용되는 B-Tree의 경우 리프 노드만 인덱스(key)와 함께 데이터(value)를 가지고 있음
            * 일반적으로 데이터는 인덱스에 해당하는 테이블 행 위치를 나타냄

* 인덱스 생성
    * 문법
        * CREATE [UNIQUE] INDEX 인덱스이름
        * ON 테이블이름(컬럼1 [ASC | DESC], 컬럼2 [ASC | DESC], ...)
            * UNIQUE INDEX를 사용하는 경우 해당 컬럼(들)에 UNIQUE 제약조건이 걸림

    * 생성된 인덱스는 'SHOW INDEX FROM 테이블이름'으로 확인

* B-Tree 인덱스의 경우 데이터의 수정, 삭제가 잦으면 삭제된 레코드의 인덱스 값 자리가 비게 되는(사용하지 않음 처리) 단편화(fragmentation) 현상이 나타나 검색시 성능 저하로 이어짐(실제 데이터 양에 비해 인덱스가 비대해지므로)
    * 인덱스 재구성이 필요 (인덱스를 다시 생성)

* 인덱스 재구성
    * 문법
        * ANALYZE TABLE 테이블이름

* 인덱스 삭제
    * 문법
        * DROP INDEX 인덱스이름 ON 테이블이름
    * 하나의 테이블에 인덱스가 많으면 데이터베이스 성능에 좋지 않은 영향을 미치므로 사용하지 않는 인덱스는 삭제해야 함

## 데이터베이스 설계
### 이상현상
* 이상현상 : 잘못 설계된 테이블로 삽입, 삭제, 수정 같은 작업을 했을 때 생기는 현상으로 데이터베이스의 일관성을 훼손하여 데이터의 무결성을 깨뜨림
    * 이상현상의 종류
        * 삭제이상 : 투플 삭제 시 하나의 정보를 삭제함으로써 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
        * 삽입이상 : 투플 삽입 시 제공되지 못하는 속성 값을 NULL 값으로 입력해야 하는 현상
        * 수정이상 : 투플 수정 시 중복된 데이터의 일부만 수정되어 데이터의 불일치 문제가 일어나는 현상 (데이터의 일관성이 깨짐)

### 함수 종속성
* 함수 종속성 : 릴레이션 R과 R에 속하는 속성 집합 X, Y가 있을 때 X 각각의 값이 Y의 값 한 개와 대응될 때(Y의 값을 유일하게 결정할 때) 'X는 Y를 함수적으로 결정한다'라고 하고 X -> Y로 표기함
    * 이때 X를 결정자, Y를 종속 속성이라고 함
* 이상현상은 비후보키 결정자 속성이 있을 때 발생하므로 릴레이션을 분해하여 비후보키 결정자 속성을 없애야 함
    * 비후보키 결정자 속성이 있다는 것은 한 릴레이션에 두 가지 이상의 정보가 저장되어 있다는 의미임
    * 분해된 부분 릴레이션의 결정자는 원래 릴레이션에 남겨두어야 부분 릴레이션이 원래 릴레이션과 조인을 통해 다시 관계를 형성할 수 있음

### 정규화
* 정규화 : 릴레이션을 분해하여 이상현상을 제거하는 과정
* 정규형
    * 릴레이션은 정규형이라는 개념으로 분류 가능하고, 정규형이 높을수록 이상현상이 줄어듦
    * 종류
        * 제 1정규형 : 릴레이션 R의 모든 속성값이 원자값을 가지면 제 1정규형이라고 함
        * 제 2정규형 : 릴레이션 R이 제 1정규형이고 모든 비후보키 속성이 후보키에 완전 함수 종속일 때 제 2정규형이라고 함
            * 완전 함수 종속 : A, B가 릴레이션 R의 속성이고 A -> B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 임의의 진부분집합 속성에 함수 종속하지 않을 경우 완전 함수 종속이라고 함
        * 제 3정규형 : 릴레이션 R이 제 2정규형이고 모든 비후보키 속성이 후보키에 비이행적으로 종속(직접 종속)할 때 제 3정규형이라고 함
            * 이행적 종속이란 A -> B, B -> C가 성립할 때 A -> C가 성립되는 함수 종속성을 말함
        * BCNF(Boyce Codd Normal Form) : 릴레이션 R에서 함수 종속성 X -> Y가 성립할 때 모든 결정자 X가 후보키이면(비후보키 결정자 속성이 없으면) BCNF임
        * 제 4정규형, 제 5정규형도 있으나 대부분의 릴레이션은 BCNF까지 정규화하면 실제적인 이상현상은 없어지므로 보통 BCNF까지 정규화를 진행함

* 정규화를 위해 릴레이션을 분해할 때는 분해된 릴레이션 간의 관계를 유지하기 위해 분해된 릴레이션에 공통 속성을 두어야 함
    * 공통 속성은 분해된 릴레이션을 다시 원래의 릴레이션으로 합성(조인)할 때 사용함
    * 어떤 속성을 공통 속성으로 해야 하는지는 무손실 분해 규칙을 통해 알 수 있음

* 무손실 분해 : 릴레이션 R을 릴레이션 R1과 R2로 분해했을 때, R1과 R2를 조인해서 R을 생성할 수 있으면 무손실 분해라고 함
    * 무손실 분해의 조건은 R1과 R2의 공통 속성이 R1 또는 R2의 키인 것임 (무손실 분해 규칙)

## 데이터베이스 관리
### 트랜잭션
* 트랜잭션 : DBMS에서 데이터를 다루는 논리적인 작업 단위
* 트랜잭션의 4가지 성질 (ACID 성질)
    * 원자성(Atomicity) : 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 함(all or nothing)
        * 트랜잭션 중간에 작업이 잘못되면 회복 알고리즘을 이용하여 변경한 내용을 취소함(undo)
    * 일관성(Consistency) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관성 있는 상태를 유지해야 함
        * 일관성 조건 중 일부는 CREATE/ALTER 문의 무결성 제약조건을 통해 명시됨
        * 무결성 제약조건에 명시되지 않은 데이터의 일관성을 유지하는 일은 프로그래머의 몫임
    * 고립성(Isolation) : 트랜잭션 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장해야 함
        * 여러 트랜잭션이 동시에 수행될 때 상호 간섭이나 데이터 충돌이 일어나지 않는 현상
    * 지속성(Durability) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함
    
### 동시성 제어
* 동시성 제어(concurrency control) : 동시에 수행되는 트랜잭션 간의 간섭으로 문제가 발생하지 않도록 트랜잭션의 실행 순서를 제어하는 기법
    * 데이터베이스는 공유를 목적으로 하기 때문에 가능한 많은 트랜잭션을 동시에 수행시켜야 함
    * 동시에 수행되는 트랜잭션은 데이터의 일관성을 훼손할 수 있음
    * 동시성과 일관성이 모두 중요함

* 갱신손실(lost update) 문제
    * 두 개의 트랜잭션이 하나의 데이터를 동시에 갱신할 때 발생
    * 한 트랜잭션의 갱신 작업을 다른 트랜잭션이 덮어씀으로써 무효화
    * 갱신손실 문제는 데이터베이스에서 절대 발생하면 안 되는 현상임

* 락(lock)
    * 트랜잭션이 데이터를 읽거나 변경할 때 데이터에 표시하는 잠금 장치
    * 트랜잭션이 락을 이용하여 자신이 사용할 데이터를 잠그면(lock) 다른 트랜잭션은 잠금이 풀릴(unlock) 때까지 기다려야(wait) 함
    * 락을 사용하면 데이터에 대한 갱신을 순차적으로 진행할 수 있음
    * 락은 트랜잭션이 다루는 데이터를 다른 트랜잭션이 접근하지 못하도록 막아 대기 상태로 만듦
    * 다른 트랜잭션을 대기 상태로 만드는 일은 사용자의 응답 시간에 영향을 주기 때문에 가능한 최소화해야 함

* 락의 유형
    * 공유락(LS, shared lock) : 데이터 읽기를 표시하는 락
    * 배타락(LX, exclusive lock) : 데이터 쓰기를 표시하는 락

* 락 호환행렬 : 락의 허용 관계를 락 호환행렬(compatibility matrix)로 표시한 것

||LS 상태|LX 상태|
|---|---|---|
|LS 요청|허용|대기|
|LX 요청|대기|대기|

* 2단계 락킹(2 phase locking)
    * 트랜잭션이 락을 걸고 해제하는 시점을 2단계로 나누어 진행하는 락킹 기법
    * 확장단계(growing phase) : 트랜잭션이 필요한 락을 획득하는 단계로, 이 단계에서는 이미 획득한 락을 해제하지 않음
    * 수축단계(shrinking phase) : 트랜잭션이 락을 해제하는 단계로, 이 단계에서는 새로운 락을 획득하지 않음
    * 즉 락의 획득과 해제를 각각 묶어서 진행한다는 것
 
 * 데드락(deadlock)
    * 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득한 상태에서 상대방 데이터에 대하여 락을 요청하여 무한 대기 상태에 빠지는 현상
    * 교착상태라고도 함
    * 트랜잭션을 중지시키고 롤백함으로써 해결

### 트랜잭션 고립 수준
* 트랜잭션 동시 실행 문제
    * 읽기/쓰기 트랜잭션 간 발생하는 문제
    * 오손 읽기(dirty read) : 커밋되지 않은 데이터(오손 데이터)를 읽어서 발생하는 문제
        * COMMIT 되지 않은 데이터는 무효가 될 가능성이 있음
    * 반복불가능 읽기(non-repeatable read) : 트랜잭션 중간에 다른 트랜잭션이 변경한 데이터를 읽으면서 발생하는 문제
        * 같은 쿼리에 대하여 이전의 결과가 반복되지 않음
    * 유령데이터 읽기(phantom read) : 트랜잭션 중간에 다른 트랜잭션이 삽입한 
    데이터를 읽으면서 발생하는 문제
        * 같은 쿼리에 대하여 이전에 없던 데이터(유령 데이터)가 나타남

* 트랜잭션 고립 수준 명령어
    * 읽기/쓰기 트랜잭션 간 고립 수준을 결정하는 명령
        * 읽기 일관성 수준을 결정
    * SQL 표준에서는 READ UNCOMMITED, READ COMMITED, REPEATABLE READ, SERIALIZABLE의 네 가지 고립 수준을 정의함

* READ UNCOMMITED(Level=0)
    * 고립 수준이 가장 낮은 명령어
    * UPDATE 문을 실행할 때는 배타락을 걸지만(갱신손실 방지), SELECT 문을 실행할 때 쿼리 대상에 공유락을 걸지 않으므로 다른 트랜잭션의 공유락/배타락이 걸린 데이터를 읽음(COMMIT되지 않은 데이터 포함)
    * 문제점 : 오손 읽기, 반복불가능 읽기, 유령데이터 읽기

* READ COMMITED(Level=1)
    * SELECT 문 - 공유락을 걸고 실행 후 바로 해지
    * UPDATE 문 - 배타락 설정
    * 문제점 : 반복불가능 읽기, 유령데이터 읽기

* REPEATABLE READ(Level=2)
    * SELECT 문 - 공유락을 걸고 트랜잭션 끝까지 유지
    * UPDATE 문 - 배타락 설정
    * 문제점 : 유령데이터 읽기

* SERIALIZABLE(Level=3)
    * 고립 수준이 가장 높은 명령어
    * SELECT 문 - 공유락을 걸고 트랜잭션 끝까지 유지
    * UPDATE 문 - 배타락 설정
    * 쿼리 대상 테이블 인덱스에 공유락을 설정하여 다른 트랜잭션에서 해당 테이블에 데이터 삽입 불가
    * 문제점 없음

### 회복
* 회복(recovery) : 데이터베이스에 장애가 발생했을 떄 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능
    * 장애 유형에는 시스템 충돌, 미디어 장애, 응용 소프트웨어 오류 등이 있음

* 트랜잭션과 회복
    * 트랜잭션은 데이터베이스 회복의 단위
    * 트랜잭션은 변경 내용(버퍼)을 로그(임시 디스크)에 기록한 후 데이터베이스에 반영함
    * DBMS의 회복 관리자는 트랜잭션의 ACID 성질 중 원자성과 지속성을 보장하여 장애로부터 데이터베이스를 보호함
        * 원자성 : 장애가 발생하면 로그의 내용을 참조하여 트랜잭션의 내용을 모두 반영하거나 아예 반영하지 않음
        * 지속성 : 트랜잭션이 일단 COMMIT한 내용은 로그를 이용하여 반드시 데이터베이스에 기록

* 로그 파일
    * 트랜잭션의 데이터 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스
    * 로그 파일에 저장된 로그의 구조는 <트랜잭션 번호, 로그 타입, 테이터 항목 이름, 수정 전 값, 수정 후 값>과 같음
    * 수행 중에 변경된 데이터는 주기억장치 버퍼에 기록되고, 데이터 변경이 일어날 때마다 변경 내용은 로그 파일에 저장됨
    * 변경 내용은 트랜잭션 시작 이후 종료까지 임의의 시점에 데이터베이스에 기록

* 로그 파일을 이용한 회복
    * 시스템 운영 중 장애가 발생하여 시스템이 다시 가동되었을 때 DBMS는 로그 파일을 먼저 살펴보고, 커밋된 트랜잭션은 완료를 확정하기 위해 재실행(REDO)하고, 중단된 트랜잭션은 롤백하기 위해 취소(UNDO)를 진행함
    * 트랜잭션의 재실행(REDO)
        * 시스템 재기동 시 로그 파일에 트랜잭션의 시작(START)과 종료(COMMIT)가 있는 경우
        * 트랜잭션이 커밋되었으나 변경 내용이 데이터베이스에 기록되지 않았을 가능성이 있으므로 로그를 이용하여 트랜잭션이 수행한 결과를 다시 반영하는 연산
    * 트랜잭션의 취소(UNDO)
        * 시스템 재기동 시 로그 파일에 트랜잭션의 시작(START)만 있고 종료(COMMIT)가 없는 경우
        * 트랜잭션이 커밋되지 못했으므로 트랜잭션이 한 일을 모두 취소해야 함
        * 트랜잭션의 변경 내용이 데이터베이스에 기록되어 있을 가능성이 있으므로 로그를 이용하여 트랜잭션이 수행한 결과를 취소하는 연산

    * 즉시갱신과 지연갱신
        * 즉시갱신 : 트랜잭션의 변경사항을 실제 데이터베이스에 반영하는 작업을 커밋 전에 동시에 진행할 수 있는 방법
        * 지연갱신 : 트랜잭션 커밋 이후에 데이터베이스 반영 작업을 진행하는 방법으로 커밋 전에는 갱신 내용이 실제 데이터베이스에 반영되지 않은 상태임
            * 지연갱신 방법을 사용하면 데이터베이스 반영 작업은 지연되지만 장애가 발생할 경우 커밋되지 않은 트랜잭션은 취소(UNDO) 작업을 할 필요가 없는 장점이 있음

* 체크포인트를 위한 회복
    * 로그를 이용한 회복은 시스템에 장애가 일어났을 때 어느 시점까지 되돌아가야 하는지 알 수 없음
    * 체크포인트(checkpoint) : 회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄이기 위하여 몇십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후 동기화한 시점을 로그 파일에 기록해두는 방법 혹은 그 시점
    * 체크포인트가 있으면 로그를 이용한 회복 기법이 간단해짐
        * 체크포인트 이전에 커밋 기록이 있는 트랜잭션의 경우
            * 아무 작업이 필요 없음
        * 체크포인트 이후에 커밋 기록이 있는 트랜잭션의 경우
            * 트랜잭션을 재실행(REDO)
        * 체크포인트 이후에 커밋 기록이 없는 트랜잭션의 경우
            * 즉시갱신의 경우 트랜잭션의 취소(UNDO)를 진행
            * 지연갱신의 경우 아무 작업이 필요 없음

 ### 보안과 권한
 * DBMS는 로그인 단계에서 DBMS 접근을 제한하는 로그인 사용자 관리와 로그인한 사용자별로 데이터베이스 및 테이블로의 접근/사용을 제한하는 권한 관리의 기능을 제공함

* 로그인 사용자 관리
    * CREATE USER
        * 사용자 계정을 생성하는 명령
        * 문법
            * CREATE USER 사용자이름@호스트이름 IDENTIFIED BY 비밀번호
    * DROP USER
        * 사용자 계정을 삭제하는 명령
        * 문법
            * DROP USER 사용자이름@호스트이름

* 권한 관리
    * 데이터 제어어(DCL) : 소유한 개체에 대한 사용 권한을 관리하는 명령
    * 권한 허가 - GRANT
        * 객체를 생성한 소유자가 대상 객체에 대한 권한을 다른 사용자에게 허가하는 명령
        * 문법
            * GRANT 권한 (컬럼리스트)
            * ON 객체 TO 사용자|롤
            * WITH GRANT OPTION
        * 롤(role) : 데이터베이스 객체에 대한 권한을 모아둔 집합
            * 사용자에게 롤을 부여할 수 있음
    * 권한 취소 - REVOKE
        * GRANT 문으로 허가한 권한을 취소, 회수하는 명령
        * 권한을 부여한 사용자는 부여한 권한의 범위 내에서 권한을 취소할 수 있음
        * 문법
            * REVOKE 권한 (컬럼리스트)
            * ON 객체 FROM 사용자|롤
    * 권한 확인은 'SHOW GRANTS FOR 사용자' 명령으로 가능

### 백업과 복원
* 백업 : 예상하지 못한 장애에 대비하여 데이터베이스를 복제하여 보관하는 작업
* 복원 : 장애가 발생하여 운영 중인 데이터에 손상이 발생했을 때 기존에 복사해 둔 백업 파일을 사용하여 복구하는 작업

* 백업의 종류
    * 전체 백업 : 데이터베이스 개체, 시스템 테이블, 데이터 등 데이터베이스 전체를 백업함
    * 차등 백업 : 마지막으로 수행한 전체 백업 이후에 변경된 데이터만 백업함
    * 증분 백업 : 데이터베이스에서 수행한 작업을 기록하고 있는 트랜잭션 로그 파일을 이용하여 백업함
        * 최초에 전체 백업을 수행한 후 로그 백업을 수행
        * 로그 백업은 로그만 저장하므로 빠르게 수행할 수 있으나 복구 시 많은 시간이 소요되므로 대량의 데이터 작업이 발생한 경우 가급적 사용하지 않는 것이 좋음

* 데이터베이스 백업 방법
    * 물리적 백업 : 데이터베이스를 구동하기 위해 필요한 모든 파일을 물리적으로 복사하는 방법
        * 콜드 백업 : 데이터베이스를 셧다운 한 후에 백업을 진행
            * 항시 운영하는 시스템에는 적합하지 않음
        * 핫 백업 : 운영 중인 데이터베이스의 파일을 복사하는 방법
            * 사용량이 적은 시간대에 수행
    * 논리적 백업 : 데이터베이스가 가지고 있는 콘텐츠(내용)를 별도의 파일로 옮겨 백업하는 방법